<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' https://*.novelai.net; script-src 'self' 'unsafe-inline' https://*.novelai.net; style-src 'self' 'unsafe-inline' https://*.novelai.net; img-src 'self' data: https://*.novelai.net https://*.perchance.org https://*.pollo.ai blob:; connect-src 'self' https://*.novelai.net wss://*.novelai.net https://*.perchance.org https://api.venice.ai https://pollo.ai https://*.pollo.ai;">
  <title>NovelAI Scene Visualizer</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: #eee;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .toolbar {
      background: #16213e;
      padding: 8px 16px;
      display: flex;
      align-items: center;
      gap: 12px;
      border-bottom: 1px solid #0f3460;
      flex-shrink: 0;
    }

    .toolbar h1 {
      font-size: 14px;
      font-weight: 600;
      color: #e94560;
    }

    .toolbar button {
      background: #0f3460;
      border: none;
      color: #eee;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: background 0.2s;
    }

    .toolbar button:hover {
      background: #e94560;
    }

    .toolbar button.primary {
      background: #e94560;
    }

    .toolbar button.primary:hover {
      background: #ff6b8a;
    }

    .toolbar button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .status {
      margin-left: auto;
      font-size: 12px;
      color: #888;
    }

    .status.connected {
      color: #4ade80;
    }

    .status.generating {
      color: #fbbf24;
    }

    .status.error {
      color: #ef4444;
    }

    .main-container {
      flex: 1;
      display: flex;
      overflow: hidden;
    }

    .webview-container {
      flex: 1;
      position: relative;
    }

    webview {
      width: 100%;
      height: 100%;
    }

    /* Image Panel */
    .image-panel {
      width: 320px;
      background: #16213e;
      border-left: 1px solid #0f3460;
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
    }

    .image-panel.hidden {
      display: none;
    }

    .image-panel-header {
      padding: 12px;
      border-bottom: 1px solid #0f3460;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .image-panel-header h2 {
      font-size: 14px;
      color: #e94560;
    }

    .image-panel-header button {
      background: transparent;
      border: none;
      color: #888;
      cursor: pointer;
      font-size: 18px;
    }

    .image-panel-content {
      flex: 1;
      padding: 12px;
      overflow-y: auto;
    }

    .scene-image {
      width: 100%;
      border-radius: 8px;
      margin-bottom: 12px;
    }

    .scene-image.placeholder {
      background: #0f3460;
      aspect-ratio: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #888;
      font-size: 14px;
    }

    .prompt-display {
      background: #0f3460;
      padding: 12px;
      border-radius: 8px;
      font-size: 11px;
      color: #aaa;
      line-height: 1.4;
      max-height: 150px;
      overflow-y: auto;
    }

    .prompt-label {
      font-size: 11px;
      color: #888;
      margin-bottom: 8px;
    }

    /* Story Suggestions */
    .suggestions-section {
      border-top: 1px solid #0f3460;
      padding-top: 12px;
      margin-top: 12px;
    }

    .suggestions-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      user-select: none;
      margin-bottom: 8px;
    }

    .suggestions-header h3 {
      font-size: 13px;
      color: #e94560;
      margin: 0;
    }

    .suggestions-header .toggle-arrow {
      font-size: 12px;
      color: #888;
      transition: transform 0.2s;
    }

    .suggestions-header .toggle-arrow.collapsed {
      transform: rotate(-90deg);
    }

    .suggestions-body.collapsed {
      display: none;
    }

    .suggestion-card {
      background: #1a1a2e;
      border: 1px solid #0f3460;
      border-left: 3px solid #a0a0a0;
      border-radius: 6px;
      padding: 10px 12px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: background 0.15s, border-color 0.15s;
    }

    .suggestion-card:hover {
      background: #1e2a4a;
      border-color: #e94560;
    }

    .suggestion-card.type-action { border-left-color: #6bcb77; }
    .suggestion-card.type-dialogue { border-left-color: #4d96ff; }
    .suggestion-card.type-narrative { border-left-color: #ffd93d; }
    .suggestion-card.type-mixed { border-left-color: #a0a0a0; }

    .suggestion-type {
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
    }

    .suggestion-card.type-action .suggestion-type { color: #6bcb77; }
    .suggestion-card.type-dialogue .suggestion-type { color: #4d96ff; }
    .suggestion-card.type-narrative .suggestion-type { color: #ffd93d; }
    .suggestion-card.type-mixed .suggestion-type { color: #a0a0a0; }

    .suggestion-text {
      font-size: 12px;
      line-height: 1.4;
      color: #ccc;
    }

    .suggestions-empty {
      text-align: center;
      padding: 16px;
      color: #666;
      font-size: 12px;
    }

    .suggestions-error {
      background: #2a1a1a;
      border-radius: 6px;
      padding: 10px;
      margin-bottom: 8px;
    }

    .suggestions-error .error-title {
      color: #ff6b6b;
      font-weight: bold;
      font-size: 12px;
      margin-bottom: 4px;
    }

    .suggestions-error .error-detail {
      color: #ff8888;
      font-size: 11px;
    }

    .suggestion-status {
      font-size: 11px;
      text-align: center;
      padding: 6px;
      border-radius: 4px;
      margin-top: 8px;
      display: none;
    }

    .suggestion-status.success {
      display: block;
      background: #1a2e1a;
      color: #4ade80;
    }

    .suggestion-status.error {
      display: block;
      background: #2e1a1a;
      color: #ef4444;
    }

    /* Loading spinner */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      color: #fbbf24;
      padding: 20px;
    }

    .spinner {
      width: 20px;
      height: 20px;
      border: 2px solid #fbbf24;
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Settings Modal */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: #16213e;
      padding: 24px;
      border-radius: 8px;
      width: 500px;
      max-width: 90%;
      max-height: 85vh;
      overflow-y: auto;
    }

    .modal h2 {
      margin-bottom: 16px;
      color: #e94560;
    }

    .form-group {
      margin-bottom: 16px;
    }

    .form-group label {
      display: block;
      margin-bottom: 4px;
      font-size: 12px;
      color: #888;
    }

    .form-group input,
    .form-group select {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #0f3460;
      border-radius: 4px;
      background: #1a1a2e;
      color: #eee;
      font-size: 14px;
    }

    .form-group input:focus,
    .form-group select:focus {
      outline: none;
      border-color: #e94560;
    }

    .form-group select {
      cursor: pointer;
    }

    .form-group select option {
      background: #1a1a2e;
    }

    .form-row {
      display: flex;
      gap: 12px;
    }

    .form-row .form-group {
      flex: 1;
    }

    .form-group.checkbox {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .form-group.checkbox input {
      width: auto;
    }

    .form-group.checkbox label {
      margin-bottom: 0;
      color: #eee;
      font-size: 13px;
    }

    .settings-section {
      margin-bottom: 20px;
      padding-bottom: 16px;
      border-bottom: 1px solid #0f3460;
    }

    .settings-section:last-of-type {
      border-bottom: none;
      margin-bottom: 12px;
    }

    .settings-section h3 {
      font-size: 13px;
      color: #e94560;
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .slider-group {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .slider-group input[type="range"] {
      flex: 1;
      -webkit-appearance: none;
      height: 4px;
      background: #0f3460;
      border-radius: 2px;
      padding: 0;
    }

    .slider-group input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #e94560;
      border-radius: 50%;
      cursor: pointer;
    }

    .slider-value {
      min-width: 40px;
      text-align: right;
      font-size: 13px;
      color: #aaa;
    }

    .v3-only {
      transition: opacity 0.2s;
    }

    .v3-only.disabled {
      opacity: 0.4;
      pointer-events: none;
    }

    .settings-section[data-provider] {
      display: none;
    }

    .settings-section[data-provider].provider-visible {
      display: block;
    }

    .key-status {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 12px;
      font-size: 13px;
    }

    .key-status .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .key-status .dot.active { background: #4ade80; }
    .key-status .dot.inactive { background: #ef4444; }

    .key-extract-btn {
      background: #0f3460;
      border: none;
      color: #eee;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: background 0.2s;
    }

    .key-extract-btn:hover { background: #e94560; }
    .key-extract-btn:disabled { opacity: 0.5; cursor: not-allowed; }

    .modal-buttons {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }

    .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }

    .modal-buttons .save {
      background: #e94560;
      color: white;
    }

    .modal-buttons .cancel {
      background: #0f3460;
      color: #eee;
    }

    /* Commit Button */
    .commit-btn {
      width: 100%;
      margin-top: 6px;
      padding: 6px 0;
      background: #1a6b3a;
      border: 1px solid #2a8b4a;
      color: #aaa;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      transition: background 0.2s, color 0.2s;
    }

    .commit-btn:hover:not(:disabled) {
      background: #2a8b4a;
      color: #fff;
    }

    .commit-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .commit-confirm {
      background: #1a2e1a;
      border: 1px solid #2a8b4a;
      border-radius: 6px;
      padding: 10px;
      margin-top: 6px;
      display: none;
    }

    .commit-confirm.active {
      display: block;
    }

    .commit-confirm label {
      font-size: 11px;
      color: #888;
      display: block;
      margin-bottom: 4px;
    }

    .commit-confirm input[type="text"] {
      width: 100%;
      padding: 4px 8px;
      border: 1px solid #0f3460;
      border-radius: 4px;
      background: #1a1a2e;
      color: #eee;
      font-size: 12px;
      margin-bottom: 8px;
    }

    .commit-confirm .commit-actions {
      display: flex;
      gap: 6px;
    }

    .commit-confirm .commit-actions button {
      flex: 1;
      padding: 4px 8px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
    }

    .commit-confirm .btn-confirm {
      background: #2a8b4a;
      color: #fff;
    }

    .commit-confirm .btn-cancel {
      background: #0f3460;
      color: #eee;
    }

    /* Toast */
    .toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: #2a8b4a;
      color: #fff;
      padding: 10px 20px;
      border-radius: 6px;
      font-size: 13px;
      z-index: 2000;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
    }

    .toast.show {
      opacity: 1;
    }

    .toast.warn {
      background: #b8860b;
    }

    /* Storyboard Viewer Modal */
    .storyboard-modal .modal-content {
      width: 850px;
      max-width: 95%;
    }

    .storyboard-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 16px;
    }

    .storyboard-header select {
      flex: 1;
      padding: 6px 10px;
      border: 1px solid #0f3460;
      border-radius: 4px;
      background: #1a1a2e;
      color: #eee;
      font-size: 14px;
    }

    .storyboard-header button {
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      color: #eee;
    }

    .storyboard-header .sb-new-btn {
      background: #2a8b4a;
    }

    .storyboard-header .sb-del-btn {
      background: #8b2a2a;
    }

    .storyboard-header .sb-rename-btn {
      background: #0f3460;
    }

    .scene-list {
      max-height: 60vh;
      overflow-y: auto;
    }

    .scene-card {
      display: flex;
      gap: 12px;
      background: #1a1a2e;
      border: 1px solid #0f3460;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 10px;
    }

    .scene-thumb {
      width: 120px;
      min-width: 120px;
      border-radius: 6px;
      overflow: hidden;
      background: #0f3460;
      display: flex;
      align-items: center;
      justify-content: center;
      aspect-ratio: 2/3;
    }

    .scene-thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .scene-thumb .thumb-placeholder {
      color: #555;
      font-size: 11px;
    }

    .scene-meta {
      flex: 1;
      min-width: 0;
    }

    .scene-meta .scene-number {
      font-size: 11px;
      color: #e94560;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .scene-meta .scene-timestamp {
      font-size: 10px;
      color: #666;
      margin-bottom: 6px;
    }

    .scene-meta .scene-prompt {
      font-size: 11px;
      color: #aaa;
      line-height: 1.3;
      max-height: 40px;
      overflow: hidden;
      margin-bottom: 4px;
    }

    .scene-meta .scene-excerpt {
      font-size: 10px;
      color: #666;
      font-style: italic;
      max-height: 30px;
      overflow: hidden;
      margin-bottom: 4px;
    }

    .scene-meta .scene-chars {
      font-size: 10px;
      color: #4d96ff;
      margin-bottom: 4px;
    }

    .scene-meta .scene-note {
      font-size: 11px;
      color: #ffd93d;
      margin-bottom: 6px;
    }

    .scene-meta .scene-info {
      font-size: 10px;
      color: #555;
      margin-bottom: 6px;
    }

    .scene-actions {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
    }

    .scene-actions button {
      padding: 3px 8px;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      font-size: 10px;
      background: #0f3460;
      color: #aaa;
      transition: background 0.2s;
    }

    .scene-actions button:hover {
      background: #e94560;
      color: #fff;
    }

    .scene-actions button.danger:hover {
      background: #8b2a2a;
    }

    .scene-empty {
      text-align: center;
      padding: 40px;
      color: #555;
    }

    .story-indicator {
      font-size: 11px;
      color: #4d96ff;
      max-width: 200px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .commit-story-label {
      font-size: 10px;
      color: #4d96ff;
      margin-bottom: 2px;
    }

    .sb-link-btn {
      background: #0f3460;
    }
  </style>
</head>
<body>
  <div class="toolbar">
    <h1>Scene Visualizer</h1>
    <button id="generateBtn" class="primary">Generate Scene</button>
    <button id="togglePanelBtn">Toggle Panel</button>
    <button id="storyboardBtn">Storyboard</button>
    <button id="settingsBtn">Settings</button>
    <button id="reloadBtn">Reload</button>
    <button id="hardReloadBtn" title="Clear cache and reload">Hard Reload</button>
    <label style="display:flex;align-items:center;gap:4px;font-size:12px;color:#aaa;cursor:pointer;user-select:none;">
      <input type="checkbox" id="autoGenerateToggle" style="cursor:pointer;">
      Auto-generate
    </label>
    <span class="story-indicator" id="storyIndicator" style="display:none;"></span>
    <span class="status" id="status">Initializing...</span>
  </div>

  <div class="main-container">
    <div class="webview-container">
      <webview
        id="novelai"
        src="https://novelai.net"
        partition="persist:novelai"
        allowpopups
      ></webview>
    </div>

    <div class="image-panel" id="imagePanel">
      <div class="image-panel-header">
        <h2>Scene Image</h2>
        <button id="closePanelBtn">&times;</button>
      </div>
      <div class="image-panel-content">
        <div id="imageContainer">
          <div class="scene-image placeholder">
            Click "Generate Scene" to create an image
          </div>
        </div>
        <div id="loadingIndicator" class="loading" style="display: none;">
          <div class="spinner"></div>
          <span>Generating...</span>
        </div>
        <div class="prompt-label">Current Prompt:</div>
        <div class="prompt-display" id="promptDisplay">
          No prompt yet. The NovelAI script will generate prompts as you write.
        </div>
        <button id="sidebarGenerateBtn" style="
          width: 100%;
          margin-top: 8px;
          padding: 6px 0;
          background: #0f3460;
          border: 1px solid #1a4a7a;
          color: #aaa;
          border-radius: 4px;
          cursor: pointer;
          font-size: 11px;
          transition: background 0.2s, color 0.2s;
        " onmouseover="this.style.background='#e94560';this.style.color='#fff'" onmouseout="this.style.background='#0f3460';this.style.color='#aaa'">Generate Image</button>

        <button id="commitBtn" class="commit-btn" disabled>Commit to Storyboard</button>
        <div id="commitConfirm" class="commit-confirm">
          <div id="commitStoryLabel" class="commit-story-label" style="display:none;"></div>
          <label>Storyboard: <span id="commitSbName">Default</span></label>
          <label>Note (optional):</label>
          <input type="text" id="commitNoteInput" placeholder="Scene annotation...">
          <div class="commit-actions">
            <button class="btn-confirm" id="commitConfirmBtn">Confirm</button>
            <button class="btn-cancel" id="commitCancelBtn">Cancel</button>
          </div>
        </div>

        <!-- Story Suggestions -->
        <div class="suggestions-section">
          <div class="suggestions-header" id="suggestionsToggle">
            <h3>Story Suggestions</h3>
            <span class="toggle-arrow" id="suggestionsArrow">&#9660;</span>
          </div>
          <div class="suggestions-body" id="suggestionsBody">
            <div id="suggestionsContainer">
              <div class="suggestions-empty">
                Suggestions will appear after the AI responds.
              </div>
            </div>
            <div id="suggestionsLoading" class="loading" style="display: none;">
              <div class="spinner"></div>
              <span>Generating suggestions...</span>
            </div>
            <div id="suggestionStatus" class="suggestion-status"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Settings Modal -->
  <div class="modal" id="settingsModal">
    <div class="modal-content">
      <h2>Settings</h2>

      <!-- Provider Selection -->
      <div class="settings-section">
        <h3>Provider</h3>
        <div class="form-group">
          <label>Image Generation Provider</label>
          <select id="provider">
            <option value="novelai">NovelAI (requires API token)</option>
            <option value="perchance">Perchance (free, lower resolution)</option>
            <option value="venice">Venice AI (API key)</option>
            <option value="pollo">Pollo AI (browser login)</option>
          </select>
        </div>
      </div>

      <!-- API Token Section (NovelAI only) -->
      <div class="settings-section" data-provider="novelai">
        <h3>Authentication</h3>
        <div class="key-status" id="novelaiTokenStatus">
          <span class="dot inactive" id="novelaiTokenDot"></span>
          <span id="novelaiTokenText">Checking...</span>
        </div>
        <div style="font-size:11px;color:#666;margin-bottom:12px;">
          Just log in to NovelAI in the main panel. The token will be captured automatically.
        </div>
        <div class="form-group">
          <label>Auto-Login Email</label>
          <input type="email" id="novelaiEmail" placeholder="Email (or set NOVELAI_EMAIL in .env)">
        </div>
        <div class="form-group">
          <label>Auto-Login Password</label>
          <input type="password" id="novelaiPassword" placeholder="Password (or set NOVELAI_PASSWORD in .env)">
        </div>
        <div style="font-size:11px;color:#666;margin-bottom:12px;">
          Credentials auto-fill the login form when needed. You can also set them in <code>app/.env</code> instead.
        </div>
        <div class="form-group">
          <label>Or enter API token manually</label>
          <input type="password" id="apiToken" placeholder="Enter your persistent API token">
        </div>
      </div>

      <!-- Perchance Key Section -->
      <div class="settings-section" data-provider="perchance">
        <h3>Perchance Key</h3>
        <div class="key-status">
          <span class="dot inactive" id="perchanceKeyDot"></span>
          <span id="perchanceKeyText">No key extracted</span>
        </div>
        <button class="key-extract-btn" id="extractKeyBtn">Extract Key (Auto)</button>
        <div class="form-group" style="margin-top: 12px;">
          <label>Or paste key manually (from browser DevTools → Network tab → userKey param)</label>
          <div style="display:flex;gap:8px;">
            <input type="text" id="perchanceManualKey" placeholder="64-character hex key" style="flex:1;font-family:monospace;font-size:12px;">
            <button class="key-extract-btn" id="saveManualKeyBtn">Save</button>
          </div>
        </div>
        <div class="form-group" style="margin-top: 8px;">
          <label>Art Style</label>
          <select id="perchanceArtStyle"></select>
        </div>
        <div class="form-group">
          <label>Guidance Scale</label>
          <div class="slider-group">
            <input type="range" id="perchanceGuidance" min="1" max="20" step="0.5" value="7">
            <span class="slider-value" id="perchanceGuidanceValue">7</span>
          </div>
        </div>
      </div>

      <!-- Venice AI Settings -->
      <div class="settings-section" data-provider="venice">
        <h3>Venice AI</h3>
        <div class="key-status" id="veniceKeyStatus">
          <span class="dot inactive" id="veniceKeyDot"></span>
          <span id="veniceKeyText">No API key</span>
        </div>
        <div class="form-group">
          <label>API Key</label>
          <div style="display:flex;gap:8px;">
            <input type="password" id="veniceApiKeyInput" placeholder="Venice AI API key" style="flex:1;">
            <button class="key-extract-btn" id="saveVeniceKeyBtn">Save</button>
          </div>
        </div>
        <div class="form-group">
          <label>Model</label>
          <select id="veniceModel"></select>
        </div>
        <div class="form-row">
          <div class="form-group">
            <label>Steps</label>
            <input type="number" id="veniceSteps" value="25" min="1" max="50">
          </div>
          <div class="form-group">
            <label>CFG Scale</label>
            <input type="number" id="veniceCfgScale" value="7" min="0" max="20" step="0.5">
          </div>
        </div>
        <div class="form-group">
          <label>Style Preset</label>
          <select id="veniceStylePreset">
            <option value="">None</option>
          </select>
        </div>
        <div class="form-row">
          <div class="form-group checkbox">
            <input type="checkbox" id="veniceSafeMode">
            <label for="veniceSafeMode">Safe Mode</label>
          </div>
          <div class="form-group checkbox">
            <input type="checkbox" id="veniceHideWatermark" checked>
            <label for="veniceHideWatermark">Hide Watermark</label>
          </div>
        </div>
      </div>

      <!-- Pollo AI Settings -->
      <div class="settings-section" data-provider="pollo">
        <h3>Pollo AI</h3>
        <div class="key-status" id="polloLoginStatus">
          <span class="dot inactive" id="polloLoginDot"></span>
          <span id="polloLoginText">Not logged in</span>
        </div>
        <div style="display:flex;gap:8px;margin-bottom:8px;">
          <button class="key-extract-btn" id="polloLoginBtn">Open Browser to Login</button>
          <button class="key-extract-btn" id="polloExtractBtn">Extract Session</button>
        </div>
        <div style="font-size:11px;color:#666;margin-bottom:12px;">
          Click "Open Browser" to log in with Google/passkey in your browser, then click "Extract Session" to import your login automatically.
        </div>
        <div class="form-group">
          <label>Model</label>
          <select id="polloModel"></select>
        </div>
        <div class="form-group">
          <label>Aspect Ratio</label>
          <select id="polloAspectRatio">
            <option value="1:1">1:1 (Square)</option>
            <option value="16:9">16:9 (Landscape)</option>
            <option value="9:16">9:16 (Portrait)</option>
            <option value="4:3">4:3 (Landscape)</option>
            <option value="3:4">3:4 (Portrait)</option>
          </select>
        </div>
      </div>

      <!-- Art Style (NovelAI only) -->
      <div class="settings-section" data-provider="novelai">
        <h3>Art Style</h3>
        <div class="form-group">
          <label>Style Preset (appended to prompts)</label>
          <select id="novelaiArtStyle"></select>
        </div>
      </div>

      <!-- Model Selection (NovelAI only) -->
      <div class="settings-section" data-provider="novelai">
        <h3>Model</h3>
        <div class="form-group">
          <label>Image Model</label>
          <select id="model">
            <option value="nai-diffusion-4-5-curated">NAI Diffusion V4.5 Curated</option>
            <option value="nai-diffusion-4-5-full">NAI Diffusion V4.5 Full</option>
            <option value="nai-diffusion-4-curated-preview">NAI Diffusion V4 Curated</option>
            <option value="nai-diffusion-4-full">NAI Diffusion V4 Full</option>
            <option value="nai-diffusion-3">NAI Diffusion Anime V3</option>
            <option value="nai-diffusion-furry-3">NAI Diffusion Furry V3</option>
          </select>
        </div>
      </div>

      <!-- Resolution -->
      <div class="settings-section">
        <h3>Resolution</h3>
        <div class="form-group">
          <label>Preset</label>
          <select id="resolutionPreset">
            <option value="square-sm">Square Small (640×640)</option>
            <option value="square">Square (832×832)</option>
            <option value="portrait-sm">Portrait Small (512×768)</option>
            <option value="portrait">Portrait (832×1216)</option>
            <option value="landscape-sm">Landscape Small (768×512)</option>
            <option value="landscape">Landscape (1216×832)</option>
            <option value="custom">Custom</option>
          </select>
        </div>
        <div class="form-row">
          <div class="form-group">
            <label>Width</label>
            <input type="number" id="imgWidth" value="832" min="256" max="1536" step="64">
          </div>
          <div class="form-group">
            <label>Height</label>
            <input type="number" id="imgHeight" value="1216" min="256" max="1536" step="64">
          </div>
        </div>
      </div>

      <!-- Generation Parameters (NovelAI only) -->
      <div class="settings-section" data-provider="novelai">
        <h3>Generation</h3>
        <div class="form-row">
          <div class="form-group">
            <label>Sampler</label>
            <select id="sampler">
              <option value="k_euler">Euler</option>
              <option value="k_euler_ancestral">Euler Ancestral</option>
              <option value="k_dpmpp_2s_ancestral">DPM++ 2S Ancestral</option>
              <option value="k_dpmpp_2m_sde">DPM++ 2M SDE</option>
              <option value="k_dpmpp_2m">DPM++ 2M</option>
              <option value="k_dpmpp_sde">DPM++ SDE</option>
            </select>
          </div>
          <div class="form-group">
            <label>Noise Schedule</label>
            <select id="noiseSchedule">
              <option value="karras">Karras</option>
              <option value="native">Native</option>
              <option value="exponential">Exponential</option>
              <option value="polyexponential">Polyexponential</option>
            </select>
          </div>
        </div>
        <div class="form-row">
          <div class="form-group">
            <label>Steps</label>
            <input type="number" id="steps" value="28" min="1" max="50">
          </div>
          <div class="form-group">
            <label>Guidance (CFG)</label>
            <input type="number" id="scale" value="5" min="1" max="20" step="0.5">
          </div>
        </div>
        <div class="form-group">
          <label>CFG Rescale</label>
          <div class="slider-group">
            <input type="range" id="cfgRescale" min="0" max="1" step="0.05" value="0">
            <span class="slider-value" id="cfgRescaleValue">0</span>
          </div>
        </div>
      </div>

      <!-- V3-Only Options (NovelAI only) -->
      <div class="settings-section v3-only" id="v3Options" data-provider="novelai">
        <h3>V3 Options (SMEA)</h3>
        <div class="form-row">
          <div class="form-group checkbox">
            <input type="checkbox" id="smea">
            <label for="smea">SMEA</label>
          </div>
          <div class="form-group checkbox">
            <input type="checkbox" id="smeaDyn">
            <label for="smeaDyn">SMEA DYN</label>
          </div>
        </div>
      </div>

      <!-- Quality Options (NovelAI only) -->
      <div class="settings-section" data-provider="novelai">
        <h3>Quality</h3>
        <div class="form-group">
          <label>UC Preset (Negative Prompt Base)</label>
          <select id="ucPreset">
            <option value="heavy">Heavy (More detailed exclusions)</option>
            <option value="light">Light (Minimal exclusions)</option>
          </select>
        </div>
        <div class="form-group checkbox">
          <input type="checkbox" id="qualityTags" checked>
          <label for="qualityTags">Add Quality Tags to Prompt</label>
        </div>
      </div>

      <div class="modal-buttons">
        <button class="cancel" id="cancelBtn">Cancel</button>
        <button class="save" id="saveBtn">Save</button>
      </div>
    </div>
  </div>

  <!-- Storyboard Viewer Modal -->
  <div class="modal storyboard-modal" id="storyboardModal">
    <div class="modal-content">
      <h2>Storyboard</h2>
      <div class="storyboard-header">
        <select id="storyboardSelect"></select>
        <button class="sb-rename-btn" id="sbRenameBtn">Rename</button>
        <button class="sb-link-btn" id="sbLinkBtn" style="display:none;">Link Story</button>
        <button class="sb-new-btn" id="sbNewBtn">New</button>
        <button class="sb-del-btn" id="sbDeleteBtn">Delete</button>
      </div>
      <div class="scene-list" id="sceneList">
        <div class="scene-empty">No scenes yet. Generate an image and commit it to start your storyboard.</div>
      </div>
      <div class="modal-buttons" style="margin-top: 12px;">
        <button class="cancel" id="storyboardCloseBtn">Close</button>
      </div>
    </div>
  </div>

  <!-- Toast -->
  <div class="toast" id="toast"></div>

  <script>
    const webview = document.getElementById('novelai');
    const status = document.getElementById('status');
    const settingsModal = document.getElementById('settingsModal');
    const imagePanel = document.getElementById('imagePanel');
    const imageContainer = document.getElementById('imageContainer');
    const loadingIndicator = document.getElementById('loadingIndicator');
    const promptDisplay = document.getElementById('promptDisplay');

    // Buttons
    const generateBtn = document.getElementById('generateBtn');
    const sidebarGenerateBtn = document.getElementById('sidebarGenerateBtn');
    const togglePanelBtn = document.getElementById('togglePanelBtn');
    const settingsBtn = document.getElementById('settingsBtn');
    const reloadBtn = document.getElementById('reloadBtn');
    const closePanelBtn = document.getElementById('closePanelBtn');
    const cancelBtn = document.getElementById('cancelBtn');
    const saveBtn = document.getElementById('saveBtn');

    // Settings elements — Provider
    const providerSelect = document.getElementById('provider');

    // Settings elements — NovelAI
    const modelSelect = document.getElementById('model');
    const resolutionPreset = document.getElementById('resolutionPreset');
    const imgWidth = document.getElementById('imgWidth');
    const imgHeight = document.getElementById('imgHeight');
    const samplerSelect = document.getElementById('sampler');
    const noiseScheduleSelect = document.getElementById('noiseSchedule');
    const stepsInput = document.getElementById('steps');
    const scaleInput = document.getElementById('scale');
    const cfgRescaleSlider = document.getElementById('cfgRescale');
    const cfgRescaleValue = document.getElementById('cfgRescaleValue');
    const smeaCheckbox = document.getElementById('smea');
    const smeaDynCheckbox = document.getElementById('smeaDyn');
    const ucPresetSelect = document.getElementById('ucPreset');
    const qualityTagsCheckbox = document.getElementById('qualityTags');
    const v3Options = document.getElementById('v3Options');

    // Settings elements — NovelAI art style
    const novelaiArtStyleSelect = document.getElementById('novelaiArtStyle');

    // Settings elements — Perchance
    const extractKeyBtn = document.getElementById('extractKeyBtn');
    const perchanceKeyDot = document.getElementById('perchanceKeyDot');
    const perchanceKeyText = document.getElementById('perchanceKeyText');
    const perchanceArtStyleSelect = document.getElementById('perchanceArtStyle');
    const perchanceGuidanceSlider = document.getElementById('perchanceGuidance');
    const perchanceGuidanceValue = document.getElementById('perchanceGuidanceValue');

    // Settings elements — Venice AI
    const veniceKeyDot = document.getElementById('veniceKeyDot');
    const veniceKeyText = document.getElementById('veniceKeyText');
    const veniceApiKeyInput = document.getElementById('veniceApiKeyInput');
    const saveVeniceKeyBtn = document.getElementById('saveVeniceKeyBtn');
    const veniceModelSelect = document.getElementById('veniceModel');
    const veniceStepsInput = document.getElementById('veniceSteps');
    const veniceCfgScaleInput = document.getElementById('veniceCfgScale');
    const veniceStylePresetSelect = document.getElementById('veniceStylePreset');
    const veniceSafeModeCheckbox = document.getElementById('veniceSafeMode');
    const veniceHideWatermarkCheckbox = document.getElementById('veniceHideWatermark');

    // Settings elements — Pollo AI
    const polloLoginDot = document.getElementById('polloLoginDot');
    const polloLoginText = document.getElementById('polloLoginText');
    const polloLoginBtn = document.getElementById('polloLoginBtn');
    const polloExtractBtn = document.getElementById('polloExtractBtn');
    const polloModelSelect = document.getElementById('polloModel');
    const polloAspectRatioSelect = document.getElementById('polloAspectRatio');

    // Auto-generate toggle
    const autoGenerateToggle = document.getElementById('autoGenerateToggle');

    // NovelAI token status elements
    const novelaiTokenDot = document.getElementById('novelaiTokenDot');
    const novelaiTokenText = document.getElementById('novelaiTokenText');

    // NovelAI credential elements
    const novelaiEmailInput = document.getElementById('novelaiEmail');
    const novelaiPasswordInput = document.getElementById('novelaiPassword');

    let currentPrompt = '';
    let currentNegativePrompt = '';
    let currentStoryExcerpt = '';
    let isGenerating = false;

    // Story state
    let currentStoryId = null;
    let currentStoryTitle = null;

    // Storyboard state
    let currentImageData = null;       // base64 of last generated image
    let currentGenerationMeta = null;  // { provider, model, resolution }
    let activeStoryboardId = null;
    let activeStoryboardName = '';

    // Storyboard elements
    const storyboardBtn = document.getElementById('storyboardBtn');
    const storyboardModal = document.getElementById('storyboardModal');
    const storyboardSelect = document.getElementById('storyboardSelect');
    const sceneList = document.getElementById('sceneList');
    const storyboardCloseBtn = document.getElementById('storyboardCloseBtn');
    const sbNewBtn = document.getElementById('sbNewBtn');
    const sbDeleteBtn = document.getElementById('sbDeleteBtn');
    const sbRenameBtn = document.getElementById('sbRenameBtn');
    const commitBtn = document.getElementById('commitBtn');
    const commitConfirm = document.getElementById('commitConfirm');
    const commitSbName = document.getElementById('commitSbName');
    const commitNoteInput = document.getElementById('commitNoteInput');
    const commitConfirmBtn = document.getElementById('commitConfirmBtn');
    const commitCancelBtn = document.getElementById('commitCancelBtn');
    const commitStoryLabel = document.getElementById('commitStoryLabel');
    const storyIndicator = document.getElementById('storyIndicator');
    const sbLinkBtn = document.getElementById('sbLinkBtn');
    const toastEl = document.getElementById('toast');

    // Resolution presets
    const RESOLUTION_PRESETS = {
      'square-sm': { width: 640, height: 640 },
      'square': { width: 832, height: 832 },
      'portrait-sm': { width: 512, height: 768 },
      'portrait': { width: 832, height: 1216 },
      'landscape-sm': { width: 768, height: 512 },
      'landscape': { width: 1216, height: 832 },
    };

    // V4 models list (for disabling SMEA)
    const V4_MODELS = [
      'nai-diffusion-4-curated-preview',
      'nai-diffusion-4-full',
      'nai-diffusion-4-5-curated',
      'nai-diffusion-4-5-full'
    ];

    // Update V3 options visibility based on model
    function updateV3Options() {
      const isV4 = V4_MODELS.includes(modelSelect.value);
      v3Options.classList.toggle('disabled', isV4);
      if (isV4) {
        smeaCheckbox.checked = false;
        smeaDynCheckbox.checked = false;
      }
    }

    // Show/hide settings sections based on selected provider
    function updateProviderSections() {
      const selected = providerSelect.value;
      document.querySelectorAll('.settings-section[data-provider]').forEach(section => {
        const match = section.dataset.provider === selected;
        section.classList.toggle('provider-visible', match);
      });
      // Clamp resolution max per provider
      const maxDimMap = { perchance: 768, venice: 1280 };
      const maxDim = maxDimMap[selected] || 1536;
      imgWidth.max = maxDim;
      imgHeight.max = maxDim;
      if (maxDim < 1536) {
        if (parseInt(imgWidth.value) > maxDim) imgWidth.value = maxDim;
        if (parseInt(imgHeight.value) > maxDim) imgHeight.value = maxDim;
      }
    }

    providerSelect.addEventListener('change', updateProviderSections);

    // Perchance guidance scale slider
    perchanceGuidanceSlider.addEventListener('input', () => {
      perchanceGuidanceValue.textContent = perchanceGuidanceSlider.value;
    });

    // Perchance key extraction
    extractKeyBtn.addEventListener('click', async () => {
      extractKeyBtn.disabled = true;
      extractKeyBtn.textContent = 'Extracting...';
      perchanceKeyText.textContent = 'Extracting key (a browser window may appear)...';
      try {
        const result = await window.sceneVisualizer.extractPerchanceKey();
        if (result.success) {
          perchanceKeyDot.className = 'dot active';
          perchanceKeyText.textContent = 'Key extracted successfully';
        } else {
          perchanceKeyDot.className = 'dot inactive';
          perchanceKeyText.textContent = result.error || 'Extraction failed or timed out';
        }
      } catch (e) {
        perchanceKeyDot.className = 'dot inactive';
        perchanceKeyText.textContent = 'Error: ' + e.message;
      } finally {
        extractKeyBtn.disabled = false;
        extractKeyBtn.textContent = 'Extract Key';
      }
    });

    // Manual key entry
    const saveManualKeyBtn = document.getElementById('saveManualKeyBtn');
    const perchanceManualKeyInput = document.getElementById('perchanceManualKey');
    saveManualKeyBtn.addEventListener('click', async () => {
      const key = perchanceManualKeyInput.value.trim();
      if (!/^[a-f0-9]{64}$/i.test(key)) {
        perchanceKeyDot.className = 'dot inactive';
        perchanceKeyText.textContent = 'Invalid key — must be 64 hex characters';
        return;
      }
      try {
        const result = await window.sceneVisualizer.setPerchanceKey(key);
        if (result.success) {
          perchanceKeyDot.className = 'dot active';
          perchanceKeyText.textContent = 'Key saved: ' + key.substring(0, 10) + '...';
          perchanceManualKeyInput.value = '';
        }
      } catch (e) {
        perchanceKeyText.textContent = 'Error saving key: ' + e.message;
      }
    });

    // Venice AI key save
    saveVeniceKeyBtn.addEventListener('click', async () => {
      const key = veniceApiKeyInput.value.trim();
      if (!key) {
        veniceKeyDot.className = 'dot inactive';
        veniceKeyText.textContent = 'Please enter an API key';
        return;
      }
      try {
        const result = await window.sceneVisualizer.setVeniceApiKey(key);
        if (result.success) {
          veniceKeyDot.className = 'dot active';
          veniceKeyText.textContent = 'API key saved';
          veniceApiKeyInput.value = '';
          // Refresh models and styles after key is saved
          await loadVeniceModels();
          await loadVeniceStyles();
        }
      } catch (e) {
        veniceKeyText.textContent = 'Error saving key: ' + e.message;
      }
    });

    // Pollo AI — open system browser for login
    polloLoginBtn.addEventListener('click', async () => {
      await window.sceneVisualizer.polloLogin();
      polloLoginText.textContent = 'Browser opened — log in, then click "Extract Session"';
    });

    // Pollo AI — extract session from browser cookie store
    polloExtractBtn.addEventListener('click', async () => {
      polloExtractBtn.disabled = true;
      polloExtractBtn.textContent = 'Extracting...';
      polloLoginText.textContent = 'Reading browser cookies...';
      try {
        const result = await window.sceneVisualizer.polloExtractSession();
        if (result.success) {
          polloLoginDot.className = 'dot active';
          polloLoginText.textContent = `Session imported from ${result.browser} (${result.cookieCount} cookies) — verifying...`;
          // Verify by loading models
          const models = await window.sceneVisualizer.getPolloModels();
          if (models.length > 0) {
            polloLoginText.textContent = `Logged in via ${result.browser} (${models.length} models available)`;
            await loadPolloModels();
          } else {
            polloLoginText.textContent = 'Session imported but could not fetch models — session may have expired';
            polloLoginDot.className = 'dot inactive';
          }
        } else {
          polloLoginDot.className = 'dot inactive';
          polloLoginText.textContent = result.error || 'Extraction failed';
        }
      } catch (e) {
        polloLoginDot.className = 'dot inactive';
        polloLoginText.textContent = 'Error: ' + e.message;
      } finally {
        polloExtractBtn.disabled = false;
        polloExtractBtn.textContent = 'Extract Session';
      }
    });

    // Load Pollo models into dropdown
    async function loadPolloModels() {
      try {
        const models = await window.sceneVisualizer.getPolloModels();
        polloModelSelect.innerHTML = '';
        if (models.length === 0) {
          const opt = document.createElement('option');
          opt.value = 'flux-schnell';
          opt.textContent = 'flux-schnell (default)';
          polloModelSelect.appendChild(opt);
          return;
        }
        for (const model of models) {
          const opt = document.createElement('option');
          opt.value = model.id;
          opt.textContent = model.brand ? `${model.name} (${model.brand})` : model.name;
          polloModelSelect.appendChild(opt);
        }
      } catch (e) {
        console.error('Failed to load Pollo models:', e);
      }
    }

    // Load Venice models into dropdown
    async function loadVeniceModels() {
      try {
        const models = await window.sceneVisualizer.getVeniceModels();
        veniceModelSelect.innerHTML = '';
        if (models.length === 0) {
          const opt = document.createElement('option');
          opt.value = 'flux-2-max';
          opt.textContent = 'flux-2-max (default)';
          veniceModelSelect.appendChild(opt);
          return;
        }
        for (const model of models) {
          const opt = document.createElement('option');
          opt.value = model.id;
          opt.textContent = model.name;
          veniceModelSelect.appendChild(opt);
        }
      } catch (e) {
        console.error('Failed to load Venice models:', e);
      }
    }

    // Load Venice styles into dropdown
    async function loadVeniceStyles() {
      try {
        const styles = await window.sceneVisualizer.getVeniceStyles();
        veniceStylePresetSelect.innerHTML = '<option value="">None</option>';
        for (const style of styles) {
          const opt = document.createElement('option');
          opt.value = style.id;
          opt.textContent = style.name;
          veniceStylePresetSelect.appendChild(opt);
        }
      } catch (e) {
        console.error('Failed to load Venice styles:', e);
      }
    }

    // Populate NovelAI art styles on load
    (async function loadNovelaiArtStyles() {
      try {
        const styles = await window.sceneVisualizer.getNovelaiArtStyles();
        novelaiArtStyleSelect.innerHTML = '';
        for (const style of styles) {
          const opt = document.createElement('option');
          opt.value = style.id;
          opt.textContent = style.name;
          novelaiArtStyleSelect.appendChild(opt);
        }
      } catch (e) {
        console.error('Failed to load NovelAI art styles:', e);
      }
    })();

    // Populate Perchance art styles on load
    (async function loadArtStyles() {
      try {
        const styles = await window.sceneVisualizer.getPerchanceArtStyles();
        perchanceArtStyleSelect.innerHTML = '';
        for (const style of styles) {
          const opt = document.createElement('option');
          opt.value = style.id;
          opt.textContent = style.name;
          perchanceArtStyleSelect.appendChild(opt);
        }
      } catch (e) {
        console.error('Failed to load art styles:', e);
      }
    })();

    // Handle resolution preset change
    resolutionPreset.addEventListener('change', () => {
      const preset = RESOLUTION_PRESETS[resolutionPreset.value];
      if (preset) {
        imgWidth.value = preset.width;
        imgHeight.value = preset.height;
      }
    });

    // Handle width/height manual change -> switch to custom
    imgWidth.addEventListener('change', () => {
      const matchingPreset = Object.entries(RESOLUTION_PRESETS).find(
        ([key, p]) => p.width === parseInt(imgWidth.value) && p.height === parseInt(imgHeight.value)
      );
      resolutionPreset.value = matchingPreset ? matchingPreset[0] : 'custom';
    });

    imgHeight.addEventListener('change', () => {
      const matchingPreset = Object.entries(RESOLUTION_PRESETS).find(
        ([key, p]) => p.width === parseInt(imgWidth.value) && p.height === parseInt(imgHeight.value)
      );
      resolutionPreset.value = matchingPreset ? matchingPreset[0] : 'custom';
    });

    // Handle CFG rescale slider
    cfgRescaleSlider.addEventListener('input', () => {
      cfgRescaleValue.textContent = cfgRescaleSlider.value;
    });

    // Handle model change
    modelSelect.addEventListener('change', updateV3Options);

    // Webview events
    webview.addEventListener('did-start-loading', () => {
      status.textContent = 'Loading...';
      status.className = 'status';
    });

    webview.addEventListener('did-finish-load', () => {
      status.textContent = 'Connected';
      status.className = 'status connected';
    });

    webview.addEventListener('did-fail-load', (e) => {
      status.textContent = 'Failed to load';
      status.className = 'status error';
      console.error('Webview load failed:', e);
    });

    // Generate Scene button
    generateBtn.addEventListener('click', async () => {
      if (isGenerating) return;

      // Try to read the prompt from the NovelAI page
      try {
        // Execute script in webview to find the prompt textarea
        const result = await webview.executeJavaScript(`
          (function() {
            // Look for the Scene Visualizer panel's textarea
            const textareas = document.querySelectorAll('textarea');
            for (const ta of textareas) {
              const val = ta.value || '';
              if (val.length > 20 && !val.startsWith('(No prompt')) {
                return val;
              }
            }
            return null;
          })()
        `);

        if (result) {
          currentPrompt = result;
          promptDisplay.textContent = currentPrompt;
          await generateImage(currentPrompt);
        } else {
          status.textContent = 'No prompt found - generate story content first';
          status.className = 'status error';
          setTimeout(() => {
            status.textContent = 'Connected';
            status.className = 'status connected';
          }, 3000);
        }
      } catch (e) {
        console.error('Error reading prompt:', e);
        status.textContent = 'Error reading prompt';
        status.className = 'status error';
      }
    });

    // Sidebar generate button — uses current prompt directly
    sidebarGenerateBtn.addEventListener('click', () => {
      if (isGenerating || !currentPrompt) return;
      generateImage(currentPrompt, currentNegativePrompt);
    });

    async function generateImage(prompt, negativePrompt) {
      isGenerating = true;
      generateBtn.disabled = true;
      status.textContent = 'Generating...';
      status.className = 'status generating';
      loadingIndicator.style.display = 'flex';

      try {
        const result = await window.sceneVisualizer.generateImage(prompt, negativePrompt || currentNegativePrompt || '');

        if (result.success) {
          currentImageData = result.imageData;
          currentGenerationMeta = result.meta || null;
          imageContainer.innerHTML = `<img src="${result.imageData}" class="scene-image" alt="Generated scene">`;
          commitBtn.disabled = false;
          status.textContent = 'Image ready';
          status.className = 'status connected';

          // Notify user about retry/fallback
          if (result.meta?.fallbackModel) {
            showToast(`Generated with fallback model: ${result.meta.fallbackModel}`, 4000, 'warn');
          } else if (result.meta?.retried) {
            showToast('Image generated after retry', 2500);
          }
        } else {
          if (result.blankDetected) {
            status.textContent = 'Image appears blank — generation may have been filtered';
          } else if (result.contentRestricted) {
            status.textContent = 'Content restricted — try a different prompt';
          } else {
            status.textContent = 'Generation failed: ' + result.error;
          }
          status.className = 'status error';
          console.error('Generation failed:', result.error || 'blank image');
        }
      } catch (e) {
        status.textContent = 'Error: ' + e.message;
        status.className = 'status error';
        console.error('Error:', e);
      } finally {
        isGenerating = false;
        generateBtn.disabled = false;
        loadingIndicator.style.display = 'none';

        setTimeout(() => {
          if (status.textContent.startsWith('Image ready') || status.textContent.startsWith('Generation failed') || status.textContent.startsWith('Error')) {
            status.textContent = 'Connected';
            status.className = 'status connected';
          }
        }, 5000);
      }
    }

    // Toggle panel
    togglePanelBtn.addEventListener('click', () => {
      imagePanel.classList.toggle('hidden');
    });

    closePanelBtn.addEventListener('click', () => {
      imagePanel.classList.add('hidden');
    });

    // Settings
    settingsBtn.addEventListener('click', async () => {
      const [token, settings, currentProvider, keyStatus, perchanceSettings, novelaiArtStyle, veniceSettings, veniceKeyStatus, polloSettings, polloLoginStatus] = await Promise.all([
        window.sceneVisualizer.getApiToken(),
        window.sceneVisualizer.getImageSettings(),
        window.sceneVisualizer.getProvider(),
        window.sceneVisualizer.getPerchanceKeyStatus(),
        window.sceneVisualizer.getPerchanceSettings(),
        window.sceneVisualizer.getNovelaiArtStyle(),
        window.sceneVisualizer.getVeniceSettings(),
        window.sceneVisualizer.getVeniceApiKeyStatus(),
        window.sceneVisualizer.getPolloSettings(),
        window.sceneVisualizer.getPolloLoginStatus(),
      ]);

      // Provider
      providerSelect.value = currentProvider || 'novelai';
      updateProviderSections();

      // Perchance key status
      if (keyStatus.hasKey) {
        perchanceKeyDot.className = 'dot active';
        perchanceKeyText.textContent = 'Key active: ' + keyStatus.preview;
      } else {
        perchanceKeyDot.className = 'dot inactive';
        perchanceKeyText.textContent = keyStatus.expired ? 'Key expired — extract a new one' : 'No key extracted';
      }

      // Perchance settings
      perchanceArtStyleSelect.value = perchanceSettings.artStyle || 'no-style';
      perchanceGuidanceSlider.value = perchanceSettings.guidanceScale || 7;
      perchanceGuidanceValue.textContent = perchanceSettings.guidanceScale || 7;

      // NovelAI art style
      novelaiArtStyleSelect.value = novelaiArtStyle || 'no-style';

      // Venice AI settings
      if (veniceKeyStatus.hasKey) {
        veniceKeyDot.className = 'dot active';
        veniceKeyText.textContent = 'API key configured';
      } else {
        veniceKeyDot.className = 'dot inactive';
        veniceKeyText.textContent = 'No API key';
      }
      veniceApiKeyInput.value = '';
      veniceApiKeyInput.placeholder = veniceKeyStatus.hasKey ? 'Key configured (enter new to replace)' : 'Venice AI API key';
      veniceStepsInput.value = veniceSettings.steps || 25;
      veniceCfgScaleInput.value = veniceSettings.cfgScale || 7;
      veniceSafeModeCheckbox.checked = veniceSettings.safeMode || false;
      veniceHideWatermarkCheckbox.checked = veniceSettings.hideWatermark !== false;
      // Load Venice models and styles (async, populates dropdowns)
      await loadVeniceModels();
      veniceModelSelect.value = veniceSettings.model || 'flux-2-max';
      await loadVeniceStyles();
      veniceStylePresetSelect.value = veniceSettings.stylePreset || '';

      // Pollo AI settings
      if (polloLoginStatus.loggedIn) {
        polloLoginDot.className = 'dot active';
        polloLoginText.textContent = 'Logged in';
      } else {
        polloLoginDot.className = 'dot inactive';
        polloLoginText.textContent = 'Not logged in';
      }
      await loadPolloModels();
      polloModelSelect.value = polloSettings.model || 'flux-schnell';
      polloAspectRatioSelect.value = polloSettings.aspectRatio || '1:1';

      // NovelAI token status
      const tokenStatus = await window.sceneVisualizer.getTokenStatus();
      if (tokenStatus.hasToken) {
        novelaiTokenDot.className = 'dot active';
        novelaiTokenText.textContent = 'Token active (auto-captured from login)';
      } else {
        novelaiTokenDot.className = 'dot inactive';
        novelaiTokenText.textContent = 'No token — log in to NovelAI';
      }

      // NovelAI credentials (show placeholder if .env has them)
      const creds = await window.sceneVisualizer.getNovelaiCredentials();
      novelaiEmailInput.value = '';
      novelaiPasswordInput.value = '';
      if (creds.hasCredentials) {
        novelaiEmailInput.placeholder = 'Configured (enter new to replace)';
        novelaiPasswordInput.placeholder = 'Configured (enter new to replace)';
      } else {
        novelaiEmailInput.placeholder = 'Email (or set NOVELAI_EMAIL in .env)';
        novelaiPasswordInput.placeholder = 'Password (or set NOVELAI_PASSWORD in .env)';
      }

      // API Token
      document.getElementById('apiToken').value = '';
      document.getElementById('apiToken').placeholder = token ? 'Token configured (enter new to replace)' : 'Enter your persistent API token';

      // Model
      modelSelect.value = settings.model || 'nai-diffusion-4-curated-preview';

      // Resolution
      imgWidth.value = settings.width || 832;
      imgHeight.value = settings.height || 1216;

      // Find matching preset
      const matchingPreset = Object.entries(RESOLUTION_PRESETS).find(
        ([key, p]) => p.width === settings.width && p.height === settings.height
      );
      resolutionPreset.value = matchingPreset ? matchingPreset[0] : 'custom';

      // Generation parameters
      samplerSelect.value = settings.sampler || 'k_euler';
      noiseScheduleSelect.value = settings.noiseSchedule || 'karras';
      stepsInput.value = settings.steps || 28;
      scaleInput.value = settings.scale || 5;
      cfgRescaleSlider.value = settings.cfgRescale || 0;
      cfgRescaleValue.textContent = settings.cfgRescale || 0;

      // V3 options (SMEA)
      smeaCheckbox.checked = settings.smea || false;
      smeaDynCheckbox.checked = settings.smeaDyn || false;

      // Quality options
      ucPresetSelect.value = settings.ucPreset || 'heavy';
      qualityTagsCheckbox.checked = settings.qualityTags !== false; // Default true

      // Update V3 options visibility
      updateV3Options();

      settingsModal.classList.add('active');
    });

    cancelBtn.addEventListener('click', () => {
      settingsModal.classList.remove('active');
    });

    saveBtn.addEventListener('click', async () => {
      // Provider
      await window.sceneVisualizer.setProvider(providerSelect.value);

      // NovelAI credentials
      const email = novelaiEmailInput.value.trim();
      const password = novelaiPasswordInput.value;
      if (email || password) {
        await window.sceneVisualizer.setNovelaiCredentials({
          ...(email && { email }),
          ...(password && { password }),
        });
      }

      // NovelAI token
      const token = document.getElementById('apiToken').value;
      if (token) {
        await window.sceneVisualizer.setApiToken(token);
      }

      // NovelAI art style
      await window.sceneVisualizer.setNovelaiArtStyle(novelaiArtStyleSelect.value);

      // Perchance settings
      await window.sceneVisualizer.setPerchanceSettings({
        artStyle: perchanceArtStyleSelect.value,
        guidanceScale: parseFloat(perchanceGuidanceSlider.value),
      });

      // Venice AI settings
      await window.sceneVisualizer.setVeniceSettings({
        model: veniceModelSelect.value,
        steps: parseInt(veniceStepsInput.value),
        cfgScale: parseFloat(veniceCfgScaleInput.value),
        stylePreset: veniceStylePresetSelect.value,
        safeMode: veniceSafeModeCheckbox.checked,
        hideWatermark: veniceHideWatermarkCheckbox.checked,
      });

      // Venice API key (only if entered)
      const veniceKey = veniceApiKeyInput.value.trim();
      if (veniceKey) {
        await window.sceneVisualizer.setVeniceApiKey(veniceKey);
        veniceApiKeyInput.value = '';
      }

      // Pollo AI settings
      await window.sceneVisualizer.setPolloSettings({
        model: polloModelSelect.value,
        aspectRatio: polloAspectRatioSelect.value,
      });

      await window.sceneVisualizer.setImageSettings({
        // Model
        model: modelSelect.value,
        // Resolution
        width: parseInt(imgWidth.value),
        height: parseInt(imgHeight.value),
        // Generation parameters
        sampler: samplerSelect.value,
        noiseSchedule: noiseScheduleSelect.value,
        steps: parseInt(stepsInput.value),
        scale: parseFloat(scaleInput.value),
        cfgRescale: parseFloat(cfgRescaleSlider.value),
        // V3 options
        smea: smeaCheckbox.checked,
        smeaDyn: smeaDynCheckbox.checked,
        // Quality options
        ucPreset: ucPresetSelect.value,
        qualityTags: qualityTagsCheckbox.checked
      });

      settingsModal.classList.remove('active');
      status.textContent = 'Settings saved';
      status.className = 'status connected';
      setTimeout(() => {
        status.textContent = 'Connected';
        status.className = 'status connected';
      }, 2000);
    });

    reloadBtn.addEventListener('click', () => {
      webview.reload();
    });

    document.getElementById('hardReloadBtn').addEventListener('click', async () => {
      status.textContent = 'Clearing cache...';
      status.className = 'status generating';
      try {
        await window.sceneVisualizer.clearWebviewCache();
        webview.reloadIgnoringCache();
        status.textContent = 'Cache cleared, reloading...';
        status.className = 'status connected';
      } catch (e) {
        console.error('[Renderer] Hard reload error:', e);
        webview.reloadIgnoringCache();
      }
    });

    // Close modal on escape
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        settingsModal.classList.remove('active');
        storyboardModal.classList.remove('active');
      }
    });

    // Listen for prompt updates from webview bridge (primary path)
    window.sceneVisualizer.onPromptUpdate((data) => {
      console.log('[Renderer] Received prompt update from bridge');
      currentPrompt = data.prompt;
      currentNegativePrompt = data.negativePrompt || '';
      currentStoryExcerpt = data.storyExcerpt || '';
      promptDisplay.textContent = currentPrompt;

      // Handle story context if included in prompt update
      if (data.storyId) {
        handleStoryContextChange(data.storyId, data.storyTitle);
      }

      // Show the image panel if hidden
      imagePanel.classList.remove('hidden');

      // Flash status
      status.textContent = 'New prompt received';
      status.className = 'status connected';
      setTimeout(() => {
        if (status.textContent === 'New prompt received') {
          status.textContent = 'Connected';
        }
      }, 3000);

      // Auto-generate if toggle is on and not already generating
      if (data.autoGenerate || autoGenerateToggle.checked) {
        if (!isGenerating) {
          generateImage(data.prompt, data.negativePrompt);
        }
      }
    });

    // Listen for token status changes
    window.sceneVisualizer.onTokenStatusChanged((data) => {
      console.log('[Renderer] Token status changed:', data);
      status.textContent = 'Token captured';
      status.className = 'status connected';
      setTimeout(() => {
        if (status.textContent === 'Token captured') {
          status.textContent = 'Connected';
        }
      }, 3000);
    });

    // ========================================================================
    // STORY SUGGESTIONS
    // ========================================================================

    const suggestionsToggle = document.getElementById('suggestionsToggle');
    const suggestionsArrow = document.getElementById('suggestionsArrow');
    const suggestionsBody = document.getElementById('suggestionsBody');
    const suggestionsContainer = document.getElementById('suggestionsContainer');
    const suggestionsLoading = document.getElementById('suggestionsLoading');
    const suggestionStatus = document.getElementById('suggestionStatus');

    // Toggle collapse
    suggestionsToggle.addEventListener('click', () => {
      suggestionsBody.classList.toggle('collapsed');
      suggestionsArrow.classList.toggle('collapsed');
    });

    /**
     * Render suggestion cards from data
     */
    function renderSuggestions(suggestions) {
      suggestionsContainer.innerHTML = '';

      if (!suggestions || suggestions.length === 0) {
        suggestionsContainer.innerHTML = '<div class="suggestions-empty">Suggestions will appear after the AI responds.</div>';
        return;
      }

      for (const suggestion of suggestions) {
        const card = document.createElement('div');
        card.className = 'suggestion-card type-' + (suggestion.type || 'mixed');

        const typeLabel = document.createElement('div');
        typeLabel.className = 'suggestion-type';
        const typeNames = { action: 'Action', dialogue: 'Dialogue', narrative: 'Narrative', mixed: 'Mixed' };
        typeLabel.textContent = typeNames[suggestion.type] || 'Mixed';

        const textEl = document.createElement('div');
        textEl.className = 'suggestion-text';
        textEl.textContent = suggestion.text;

        card.appendChild(typeLabel);
        card.appendChild(textEl);

        card.addEventListener('click', () => {
          insertSuggestionIntoEditor(suggestion);
        });

        suggestionsContainer.appendChild(card);
      }
    }

    /**
     * Show a temporary status message in the suggestions section
     */
    function showSuggestionStatus(message, type) {
      suggestionStatus.textContent = message;
      suggestionStatus.className = 'suggestion-status ' + type;
      setTimeout(() => {
        suggestionStatus.className = 'suggestion-status';
        suggestionStatus.style.display = 'none';
      }, 3000);
    }

    /**
     * Insert suggestion text into NovelAI's story editor via executeJavaScript.
     * Prefers the companion script's document.append API (updates NovelAI's own
     * document model). Falls back to direct ProseMirror manipulation if the
     * companion script isn't running.
     */
    async function insertSuggestionIntoEditor(suggestion) {
      try {
        const text = suggestion.text;
        const result = await webview.executeJavaScript(`
          (async function() {
            // Strategy 1: Use companion script's API (most reliable — updates NovelAI's document model)
            if (window.__sceneVisInsert) {
              try {
                const ok = await window.__sceneVisInsert(${JSON.stringify(text)});
                if (ok) return { success: true, method: 'document-append' };
              } catch (e) {
                console.warn('[SceneVis] __sceneVisInsert threw:', e);
              }
            }

            // Strategy 2: Direct ProseMirror transaction (fallback if companion script not running)
            const editor = document.querySelector('.ProseMirror[contenteditable="true"]');
            if (!editor) return { success: false, error: 'No editor found' };

            const before = editor.textContent.length;

            try {
              const view = editor.pmViewDesc && editor.pmViewDesc.view;
              if (view && view.state) {
                editor.focus();
                const { state } = view;
                // Find the last textblock and insert at its end
                let insertPos = null;
                state.doc.descendants((node, pos) => {
                  if (node.isTextblock) {
                    insertPos = pos + 1 + node.content.size;
                  }
                });
                if (insertPos !== null) {
                  const tr = state.tr.insertText('\\n' + ${JSON.stringify(text)}, insertPos);
                  view.dispatch(tr);
                  if (editor.textContent.length > before) {
                    return { success: true, method: 'prosemirror-transaction' };
                  }
                }
              }
            } catch (e) {
              console.warn('[SceneVis] ProseMirror transaction error:', e);
            }

            // Strategy 3: execCommand fallback
            try {
              editor.focus();
              const sel = window.getSelection();
              const range = document.createRange();
              range.selectNodeContents(editor);
              range.collapse(false);
              sel.removeAllRanges();
              sel.addRange(range);
              document.execCommand('insertText', false, ${JSON.stringify(text)});
              if (editor.textContent.length > before) {
                return { success: true, method: 'execCommand' };
              }
            } catch (e) {}

            return { success: false, error: 'All insertion strategies failed' };
          })()
        `);

        if (result && result.success) {
          console.log('[Renderer] Suggestion inserted via', result.method);
          showSuggestionStatus('Suggestion inserted into editor', 'success');
        } else {
          console.warn('[Renderer] Suggestion insertion failed:', result?.error);
          showSuggestionStatus(result?.error || 'Could not insert suggestion', 'error');
        }
      } catch (e) {
        console.error('[Renderer] Error inserting suggestion:', e);
        showSuggestionStatus('Error inserting suggestion', 'error');
      }
    }

    // Listen for suggestions from webview bridge
    window.sceneVisualizer.onSuggestionsUpdate((data) => {
      console.log('[Renderer] Received suggestions update:', data);

      if (data.isLoading) {
        suggestionsLoading.style.display = 'flex';
        suggestionsContainer.innerHTML = '';
        // Auto-expand if collapsed
        suggestionsBody.classList.remove('collapsed');
        suggestionsArrow.classList.remove('collapsed');
        return;
      }

      suggestionsLoading.style.display = 'none';

      if (data.error) {
        suggestionsContainer.innerHTML = '';
        const errDiv = document.createElement('div');
        errDiv.className = 'suggestions-error';
        errDiv.innerHTML = '<div class="error-title">Error generating suggestions</div>' +
          '<div class="error-detail">' + (data.error.length > 100 ? data.error.slice(0, 100) + '...' : data.error) + '</div>';
        suggestionsContainer.appendChild(errDiv);
        return;
      }

      if (data.suggestions) {
        renderSuggestions(data.suggestions);
        // Auto-expand when new suggestions arrive
        if (data.suggestions.length > 0) {
          suggestionsBody.classList.remove('collapsed');
          suggestionsArrow.classList.remove('collapsed');
        }
      }
    });

    // ========================================================================
    // STORY CONTEXT — auto-switch storyboards per story
    // ========================================================================

    async function handleStoryContextChange(storyId, storyTitle) {
      if (!storyId || storyId === currentStoryId) return;

      currentStoryId = storyId;
      currentStoryTitle = storyTitle || null;

      // Update toolbar indicator
      if (storyTitle) {
        storyIndicator.textContent = 'Story: ' + storyTitle;
        storyIndicator.style.display = '';
      } else {
        storyIndicator.textContent = 'Story: ' + storyId.slice(0, 12);
        storyIndicator.style.display = '';
      }

      // Auto-switch storyboard
      try {
        const result = await window.sceneVisualizer.storyboardGetOrCreateForStory(storyId, storyTitle);
        if (result && result.id) {
          activeStoryboardId = result.id;
          activeStoryboardName = result.name;
          await window.sceneVisualizer.storyboardSetActive(result.id);
          commitSbName.textContent = activeStoryboardName;
          if (result.created) {
            showToast('Storyboard created for story: ' + (storyTitle || storyId.slice(0, 12)));
          } else {
            console.log('[Renderer] Switched to storyboard:', activeStoryboardName);
          }
          // Update commit story label
          if (storyTitle) {
            commitStoryLabel.textContent = 'Story: ' + storyTitle;
            commitStoryLabel.style.display = '';
          }
        }
      } catch (e) {
        console.error('[Renderer] Error auto-switching storyboard:', e);
      }
    }

    // Listen for story context updates from webview
    window.sceneVisualizer.onStoryContextUpdate((data) => {
      console.log('[Renderer] Story context update:', data);
      handleStoryContextChange(data.storyId, data.storyTitle);
    });

    // ========================================================================
    // STORYBOARD
    // ========================================================================

    function showToast(msg, duration = 2500, variant = '') {
      toastEl.textContent = msg;
      toastEl.className = 'toast show' + (variant ? ' ' + variant : '');
      setTimeout(() => { toastEl.className = 'toast'; }, duration);
    }

    // Init storyboard state on load
    async function initStoryboard() {
      try {
        const data = await window.sceneVisualizer.storyboardList();
        activeStoryboardId = data.activeStoryboardId;
        const active = data.storyboards.find(sb => sb.id === activeStoryboardId);
        activeStoryboardName = active ? active.name : '';
        commitSbName.textContent = activeStoryboardName || 'Default';
      } catch (e) {
        console.log('[Renderer] Storyboard init:', e);
      }
    }
    initStoryboard();

    // Commit button flow
    commitBtn.addEventListener('click', () => {
      commitSbName.textContent = activeStoryboardName || 'Default';
      if (currentStoryTitle) {
        commitStoryLabel.textContent = 'Story: ' + currentStoryTitle;
        commitStoryLabel.style.display = '';
      } else {
        commitStoryLabel.style.display = 'none';
      }
      commitNoteInput.value = '';
      commitConfirm.classList.add('active');
    });

    commitCancelBtn.addEventListener('click', () => {
      commitConfirm.classList.remove('active');
    });

    commitConfirmBtn.addEventListener('click', async () => {
      if (!currentImageData) return;

      commitConfirmBtn.disabled = true;
      commitConfirmBtn.textContent = 'Saving...';

      try {
        const sceneData = {
          imageData: currentImageData,
          prompt: currentPrompt,
          negativePrompt: currentNegativePrompt,
          storyExcerpt: currentStoryExcerpt,
          characters: [],
          provider: currentGenerationMeta?.provider || '',
          model: currentGenerationMeta?.model || '',
          resolution: currentGenerationMeta?.resolution || {},
          note: commitNoteInput.value.trim(),
        };

        const result = await window.sceneVisualizer.storyboardCommitScene(activeStoryboardId, sceneData);

        if (result.success) {
          // Update active storyboard ID if it was auto-created
          if (result.storyboardId && result.storyboardId !== activeStoryboardId) {
            activeStoryboardId = result.storyboardId;
          }
          await initStoryboard();
          // Refresh viewer if it's open
          if (storyboardModal.classList.contains('active')) {
            await refreshStoryboardSelect();
            await renderSceneList();
          }
          showToast('Scene committed to storyboard');
          commitConfirm.classList.remove('active');
        } else {
          showToast('Failed: ' + (result.error || 'unknown error'));
        }
      } catch (e) {
        showToast('Error: ' + e.message);
      } finally {
        commitConfirmBtn.disabled = false;
        commitConfirmBtn.textContent = 'Confirm';
      }
    });

    // Storyboard viewer
    storyboardBtn.addEventListener('click', () => openStoryboardViewer());
    storyboardCloseBtn.addEventListener('click', () => storyboardModal.classList.remove('active'));

    async function openStoryboardViewer() {
      storyboardModal.classList.add('active');
      await refreshStoryboardSelect();
      await renderSceneList();
    }

    async function refreshStoryboardSelect() {
      const data = await window.sceneVisualizer.storyboardList();
      storyboardSelect.innerHTML = '';

      if (data.storyboards.length === 0) {
        const opt = document.createElement('option');
        opt.value = '';
        opt.textContent = 'No storyboards yet';
        storyboardSelect.appendChild(opt);
        activeStoryboardId = null;
        activeStoryboardName = '';
        sbLinkBtn.style.display = 'none';
        return;
      }

      // Group storyboards: Current Story, Other Stories, Unlinked
      const currentStoryGroup = [];
      const otherStoryGroup = [];
      const unlinkedGroup = [];

      for (const sb of data.storyboards) {
        if (sb.storyId && sb.storyId === currentStoryId) {
          currentStoryGroup.push(sb);
        } else if (sb.storyId) {
          otherStoryGroup.push(sb);
        } else {
          unlinkedGroup.push(sb);
        }
      }

      function addOptions(group, parent, showStoryTitle) {
        for (const sb of group) {
          const opt = document.createElement('option');
          opt.value = sb.id;
          const suffix = ` (${sb.sceneCount} scenes)`;
          opt.textContent = (showStoryTitle && sb.storyTitle) ? `${sb.name} — ${sb.storyTitle}${suffix}` : `${sb.name}${suffix}`;
          if (sb.id === data.activeStoryboardId) opt.selected = true;
          parent.appendChild(opt);
        }
      }

      const nonEmptyGroups = [currentStoryGroup, otherStoryGroup, unlinkedGroup].filter(g => g.length > 0).length;
      const hasGroups = nonEmptyGroups > 1;

      if (hasGroups) {
        if (currentStoryGroup.length > 0) {
          const grp = document.createElement('optgroup');
          grp.label = 'Current Story';
          addOptions(currentStoryGroup, grp, false);
          storyboardSelect.appendChild(grp);
        }
        if (unlinkedGroup.length > 0) {
          const grp = document.createElement('optgroup');
          grp.label = 'Unlinked';
          addOptions(unlinkedGroup, grp, false);
          storyboardSelect.appendChild(grp);
        }
        if (otherStoryGroup.length > 0) {
          const grp = document.createElement('optgroup');
          grp.label = 'Other Stories';
          addOptions(otherStoryGroup, grp, true);
          storyboardSelect.appendChild(grp);
        }
      } else {
        // No grouping needed — flat list
        addOptions(data.storyboards, storyboardSelect, false);
      }

      activeStoryboardId = data.activeStoryboardId;
      const active = data.storyboards.find(sb => sb.id === activeStoryboardId);
      activeStoryboardName = active ? active.name : '';
      commitSbName.textContent = activeStoryboardName || 'Default';

      // Show/hide link button based on whether active storyboard is linked and story is detected
      if (active && currentStoryId) {
        if (active.storyId) {
          sbLinkBtn.textContent = 'Unlink';
          sbLinkBtn.style.display = '';
        } else {
          sbLinkBtn.textContent = 'Link Story';
          sbLinkBtn.style.display = '';
        }
      } else {
        sbLinkBtn.style.display = 'none';
      }
    }

    storyboardSelect.addEventListener('change', async () => {
      const id = storyboardSelect.value;
      if (id) {
        await window.sceneVisualizer.storyboardSetActive(id);
        activeStoryboardId = id;
        // Look up name from data, not display text
        const data = await window.sceneVisualizer.storyboardList();
        const found = data.storyboards.find(sb => sb.id === id);
        activeStoryboardName = found ? found.name : '';
        commitSbName.textContent = activeStoryboardName;
        await renderSceneList();
        await refreshStoryboardSelect(); // Refresh link button state
      }
    });

    sbNewBtn.addEventListener('click', async () => {
      const defaultName = currentStoryTitle || '';
      const name = prompt('Storyboard name:', defaultName);
      if (!name || !name.trim()) return;
      const result = await window.sceneVisualizer.storyboardCreate(name.trim());
      // Pre-link to current story if detected
      if (currentStoryId) {
        await window.sceneVisualizer.storyboardAssociateWithStory(result.id, currentStoryId, currentStoryTitle || '');
      }
      await window.sceneVisualizer.storyboardSetActive(result.id);
      activeStoryboardId = result.id;
      activeStoryboardName = result.name;
      commitSbName.textContent = activeStoryboardName;
      await refreshStoryboardSelect();
      await renderSceneList();
    });

    sbDeleteBtn.addEventListener('click', async () => {
      if (!activeStoryboardId) return;
      if (!confirm(`Delete storyboard "${activeStoryboardName}" and all its scenes?`)) return;
      const result = await window.sceneVisualizer.storyboardDelete(activeStoryboardId);
      activeStoryboardId = result.activeStoryboardId;
      await refreshStoryboardSelect();
      await renderSceneList();
    });

    sbRenameBtn.addEventListener('click', async () => {
      if (!activeStoryboardId) return;
      const name = prompt('New name:', activeStoryboardName);
      if (!name || !name.trim()) return;
      await window.sceneVisualizer.storyboardRename(activeStoryboardId, name.trim());
      activeStoryboardName = name.trim();
      commitSbName.textContent = activeStoryboardName;
      await refreshStoryboardSelect();
    });

    sbLinkBtn.addEventListener('click', async () => {
      if (!activeStoryboardId || !currentStoryId) return;
      const data = await window.sceneVisualizer.storyboardList();
      const active = data.storyboards.find(sb => sb.id === activeStoryboardId);

      if (active && active.storyId) {
        // Unlink
        await window.sceneVisualizer.storyboardDissociateFromStory(activeStoryboardId);
        showToast('Storyboard unlinked from story');
      } else {
        // Link
        await window.sceneVisualizer.storyboardAssociateWithStory(activeStoryboardId, currentStoryId, currentStoryTitle || '');
        showToast('Storyboard linked to: ' + (currentStoryTitle || currentStoryId.slice(0, 12)));
      }
      await refreshStoryboardSelect();
    });

    async function renderSceneList() {
      if (!activeStoryboardId) {
        sceneList.innerHTML = '<div class="scene-empty">No storyboards yet. Generate an image and commit it to start your storyboard.</div>';
        return;
      }

      const scenes = await window.sceneVisualizer.storyboardGetScenes(activeStoryboardId);
      if (!scenes || scenes.length === 0) {
        sceneList.innerHTML = '<div class="scene-empty">No scenes yet. Generate an image and click "Commit to Storyboard".</div>';
        return;
      }

      sceneList.innerHTML = '';

      for (let i = 0; i < scenes.length; i++) {
        const scene = scenes[i];
        const card = document.createElement('div');
        card.className = 'scene-card';

        // Thumbnail (lazy loaded)
        const thumbDiv = document.createElement('div');
        thumbDiv.className = 'scene-thumb';
        thumbDiv.innerHTML = '<span class="thumb-placeholder">Loading...</span>';
        card.appendChild(thumbDiv);

        // Lazy load image (capture storyboardId to avoid race condition)
        (async (td, sid, sbId) => {
          const imgData = await window.sceneVisualizer.storyboardGetSceneImage(sbId, sid);
          if (imgData) {
            td.innerHTML = `<img src="${imgData}" alt="Scene">`;
          } else {
            td.innerHTML = '<span class="thumb-placeholder">Missing</span>';
          }
        })(thumbDiv, scene.id, activeStoryboardId);

        // Metadata
        const meta = document.createElement('div');
        meta.className = 'scene-meta';

        const num = document.createElement('div');
        num.className = 'scene-number';
        num.textContent = `Scene ${i + 1}`;
        meta.appendChild(num);

        const ts = document.createElement('div');
        ts.className = 'scene-timestamp';
        ts.textContent = new Date(scene.committedAt).toLocaleString();
        meta.appendChild(ts);

        if (scene.prompt) {
          const pr = document.createElement('div');
          pr.className = 'scene-prompt';
          pr.textContent = scene.prompt.length > 120 ? scene.prompt.slice(0, 120) + '...' : scene.prompt;
          meta.appendChild(pr);
        }

        if (scene.storyExcerpt) {
          const ex = document.createElement('div');
          ex.className = 'scene-excerpt';
          ex.textContent = scene.storyExcerpt.length > 100 ? '...' + scene.storyExcerpt.slice(-100) : scene.storyExcerpt;
          meta.appendChild(ex);
        }

        if (scene.characters && scene.characters.length > 0) {
          const ch = document.createElement('div');
          ch.className = 'scene-chars';
          ch.textContent = 'Characters: ' + scene.characters.join(', ');
          meta.appendChild(ch);
        }

        if (scene.note) {
          const nt = document.createElement('div');
          nt.className = 'scene-note';
          nt.textContent = scene.note;
          meta.appendChild(nt);
        }

        const info = document.createElement('div');
        info.className = 'scene-info';
        const parts = [];
        if (scene.provider) parts.push(scene.provider);
        if (scene.model) parts.push(scene.model);
        if (scene.resolution && scene.resolution.width) parts.push(`${scene.resolution.width}x${scene.resolution.height}`);
        if (parts.length > 0) info.textContent = parts.join(' | ');
        meta.appendChild(info);

        // Actions
        const actions = document.createElement('div');
        actions.className = 'scene-actions';

        const editNoteBtn = document.createElement('button');
        editNoteBtn.textContent = 'Edit Note';
        editNoteBtn.addEventListener('click', async () => {
          const note = prompt('Scene note:', scene.note || '');
          if (note === null) return;
          await window.sceneVisualizer.storyboardUpdateSceneNote(activeStoryboardId, scene.id, note);
          await renderSceneList();
        });
        actions.appendChild(editNoteBtn);

        const regenBtn = document.createElement('button');
        regenBtn.textContent = 'Load Prompt';
        regenBtn.addEventListener('click', () => {
          currentPrompt = scene.prompt;
          currentNegativePrompt = scene.negativePrompt || '';
          promptDisplay.textContent = currentPrompt;
          imagePanel.classList.remove('hidden');
          storyboardModal.classList.remove('active');
          showToast('Prompt loaded — click Generate');
        });
        actions.appendChild(regenBtn);

        if (i > 0) {
          const upBtn = document.createElement('button');
          upBtn.textContent = 'Move Up';
          upBtn.addEventListener('click', async () => {
            const ids = scenes.map(s => s.id);
            [ids[i - 1], ids[i]] = [ids[i], ids[i - 1]];
            await window.sceneVisualizer.storyboardReorderScenes(activeStoryboardId, ids);
            await renderSceneList();
          });
          actions.appendChild(upBtn);
        }

        if (i < scenes.length - 1) {
          const downBtn = document.createElement('button');
          downBtn.textContent = 'Move Down';
          downBtn.addEventListener('click', async () => {
            const ids = scenes.map(s => s.id);
            [ids[i], ids[i + 1]] = [ids[i + 1], ids[i]];
            await window.sceneVisualizer.storyboardReorderScenes(activeStoryboardId, ids);
            await renderSceneList();
          });
          actions.appendChild(downBtn);
        }

        const delBtn = document.createElement('button');
        delBtn.className = 'danger';
        delBtn.textContent = 'Delete';
        delBtn.addEventListener('click', async () => {
          if (!confirm('Delete this scene?')) return;
          await window.sceneVisualizer.storyboardDeleteScene(activeStoryboardId, scene.id);
          await renderSceneList();
          await refreshStoryboardSelect();
        });
        actions.appendChild(delBtn);

        meta.appendChild(actions);
        card.appendChild(meta);
        sceneList.appendChild(card);
      }
    }

    // Fallback polling — reduced interval since bridge is primary
    setInterval(async () => {
      if (!isGenerating) {
        try {
          const result = await webview.executeJavaScript(`
            (function() {
              const textareas = document.querySelectorAll('textarea');
              for (const ta of textareas) {
                const val = ta.value || '';
                if (val.length > 20 && !val.startsWith('(No prompt')) {
                  return val;
                }
              }
              return null;
            })()
          `);

          if (result && result !== currentPrompt) {
            currentPrompt = result;
            promptDisplay.textContent = currentPrompt;
          }
        } catch (e) {
          // Ignore errors during polling
        }
      }
    }, 10000);
  </script>
</body>
</html>
